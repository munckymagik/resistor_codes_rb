#!/usr/bin/env ruby
require 'rainbow'

COLOURS = %i[
  black
  brown
  red
  orange
  yellow
  green
  blue
  violet
  gray
  white
  gold
  silver
].freeze

MULTS = ((0..9).to_a + [-1, -2]).map { |p| 10**p }

def random_code
  [
    (1..9).to_a.sample,
    (0..9).to_a.sample,
    (0..9).to_a.sample,
    (0..11).to_a.sample
  ]
end

def to_colours_names(code)
  COLOURS.values_at(*code)
end

def map_colour(colour)
  # For some reason the gold colour looks more like yellow and vice-versa
  {
    yellow: :gold,
    gold: :yellow
  }.fetch(colour, colour)
end

def render_band(str, colour)
  Rainbow(str).bg(map_colour(colour))
end

def render_code(code)
  body = Rainbow('|').color(:lightblue)
  wire = Rainbow('———').color(:darkgray)
  names = to_colours_names(code)
  bands = names.map { |c| render_band(' ', c) }
  colour_hint = " (#{names.join(' ')})"

  [wire, body, bands.join(body), body, wire, colour_hint].join
end

def render_key
  digits = COLOURS[0..9].each_with_index.map { |c, i| render_band(i, c) }.join(' ')
  multipliers = MULTS.each_with_index.map { |m, i| render_band(m, COLOURS.fetch(i)) }.join(' ')
  "Digits:      #{digits}\nMultipliers: #{multipliers}"
end

def format_as_ohms(value)
  return '0Ω' if value == 0.0
  [[10**9, 'G'], [10**6, 'M'], [10**3, 'K'], [10**0, '']].each do |denominator, postfix|
    result = value / denominator
    return format('%g%s', result, postfix) if result >= 1.0
  end
end

def render_outcome(answer, response)
  if response == answer
    puts "#{Rainbow('CORRECT').green} #{answer}Ω"
  else
    puts Rainbow('WRONG').red
    puts "ANS: #{Rainbow(answer).green}Ω, YOURS: #{Rainbow(response).red}Ω"
  end
end

def code_to_number(code)
  ((code[0] * 100 + code[1] * 10 + code[2]) * MULTS[code[3]]).to_f
end

def code_to_str(code)
  number = code_to_number(code)
  format_as_ohms(number)
end

def parse_response(answer)
  answer.strip.upcase
end

def prompt(code)
  puts render_code(code)
  print '? '
  parse_response(gets)
end

begin
  puts render_key
  puts

  10.times do
    code = random_code
    answer = code_to_str(code)
    response = prompt(code)
    puts render_outcome(answer, response)
    puts
  end
rescue Interrupt
  puts
  puts 'Bye!'
end
